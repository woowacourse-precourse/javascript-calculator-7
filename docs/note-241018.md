# 241018 D+4

- `//`과 `\n` 사이의 문자 중 첫번째 문자를 찾으려면?

> - **`\n`과 `\\n`은 다르다!**
> - `\n` 줄바꿈 특수문자
> - `\\n` 역슬래시(\) 와 텍스트인 "\n"

- 특수문자 정규식 `/[^a-zA-Z0-9\s]/`
  `/\/\/[^a-zA-Z0-9\s][^]*?\n/`

- 역슬래시와 슬래시와 공백 문자, 알파벳을 찾는 정규식 -> 커스텀 문자가 확인된 문자열을 이 정규식으로 분해
  `let reg = /[\\/\sA-Za-z]/g;`

- `//` 로 시작하는지 확인하는 정규식 -> 커스텀 문자를 확인할 때 사용
  `let begin_reg = /[^//]/;`

```
let tester1 = "//;\\n1";
let tester2 = "//;\\n1;2;3";

let begin_reg = /^\/\//;
let delimiter;
let reg;


// 구분자 확인
delimiter = tester1.match(begin_reg)[0]

// 역슬래시와 슬래시, 공백문자, 알파벳을 찾는 정규식에 구분자 추가
reg = RegExp(`[\\\\/\\sA-Za-z${delimiter}]`, 'g');

// 처음 인풋을 구분자로 나누고 구분자 뒤의 문자열을 다시 특수문자로 나눔
let tester_array = tester1.split(reg);
let answer = 0;
for(let i = 0; i < tester_array.length; i++){
    answer= Number(tester_array[i]) + answer;
}
console.log(` 결과 : ${answer}`);

```

- 이렇게 하면 1번과 2번 테스트는 통과

  - 그렇다면 이제 어떤 것이 커스텀 문자를 쓰는지 거르는 작업 필요

  ```
  // "//" 로 시작되는 문자열은 값을 내놓고 그렇지 않은 경우 null 을 내놓음
  let is_using_custom_reg = input.match(begin_reg);

  if(is_using_custom_reg){

  }
  ```

  **구분자와 양수로 구성된 문자열**을 입력 받아야 함

  - 일단 특수문자를 확인
  - 그 후에 처리된 숫자가 양수인지 음수인지 판별
    => 예외 처리에서 이 외의 문자가 포함된 문자열은 ERROR 처리 해야함

### 다시 생각해보는 흐름

- 문자열을 받음
- 문자열에 특수문자 `/[.;/\n]/g`이 포함되어 있는지 혹은 빈 문자열 인지 -> 특수문자 색출 함수

  - 두 개의 상황이라면 `//`를 사용한 경우를 구분 -> `//` 사용 문자열 검열 함수
    - `//`를 사용했다면 구분자를 색출해서 결과를 계산하는 함수 적용 -> 구분자 색출 함수, 숫자 배열 합 도출 함수
      - 계산할 때 음수를 확인 -> 양수 판별 함수
    - 아닌 경우라면 `/[,:]/` 로 계산하는 함수 사용 -> 숫자 배열 함수 2
      - 계산할 때 음수를 확인 -> 양수 판별 함수
    - 둘 다 아니다? 에러

- 3가지 상황 제외하고는 모두 에러 처리

특수문자 색출 함수

```
let input;

let checker = {
  special_chracter: RegExp(/[,;/\n]/,"g"),
  empty_string :  RegExp(/^$/),
};

```

## 정규 표현식

[mdn 정규 표현식](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Regular_expressions)
정규 표현식 혹은 정규식은 특정 문자 조합을 찾기 위한 패턴
JS 에서는 정규 표현식도 객체

### 정규 표현식 인스턴스 메서드

- `RegExp`
  - `exec()` : `match()` 메서드와 유사하지만 무조건 첫번째 매칭 결과만 반환
  - `test()` : 문자열이 정규표현식과 매칭되면 true 아니면 false 반환
- `String`의 다른 메서드들과 함께 사용 가능
  - `match()` : 문자열에서 정규 표현식에 매칭되는 항목들을 "배열"로 반환
  - `matchAll()` : 문자열에서 정규식에 반하는 모든 반복자를 반환
  - `replace()` : 문자열에서 특정 패턴(문자열 혹은 정규식)으로 일치하는 항목을 교체해 새로운 문자열을 반환. 패턴이 문자열일 경우 첫번째만 교체됨.
  - `search()` : 정규식과 이 문자열 간에 일치하는 항목이 있는지 검색하여 문자열에처 *첫 번째*로 일치하는 항목의 인덱스를 반환
  - `split()` : 문자열을 정규 표현식에 매칭되는 항목으로 쪼개어 "배열"로 반환

### 정규 표현식 만들기

- 슬래시로 패턴을 감싸서 작성 `const re = /ab+c/;`
- 정규 표현식 리터럴은 스크립트를 불러올 때 컴파일됨 => 바뀔 일이 없는 패턴의 경우 리터럴을 사용하면 성능이 향상됨
  `const re = new RegExp("ab+c")`

### 정규 표현식 패턴 작성하기

- 단순 패턴 : 문자열을 있는 그대로 탐색
- 특수 문자 : 직접적인 일치 이상의 탐색이 필요할 때 특수 문자 사용

#### Assertions

어서션에는 줄이나 단어의 시작과 끝을 나타내는 경계와, 일치가 가능한 방법을 나타내는 패턴(전방탐색, 후방탐색, 조건 표현식 등)이 포함됩니다.

- `^` : 인풋의 시작에 매치되는지 확인
- `$` : 인풋의 끝에 매치되는지 확인
- `\b` : 영문자 영역 확인, 다른 영문자가 앞이나 뒤에 붙지 말아햐 함
- `\B` : 영문자 아닌 영역 확인

#### Character classes

- `.` : 와일드 카드? 라인 터미네이터 (`\n, \r, \u2028, \u2029`)를 제외한 모든 단일 글자(any single character)와 매치됨
- `\d` : 모든 아라비아 숫자를 매치 == `[0-9]`
- `\D` : 아라비아 숫자가 character를 매치 == `[^0-9]`
- `\w` : word character class escape 언더스코어를 포함한 기본 라틴 알파벳과 숫자에 매치 == `[A-Za-z0-9_]`
- `\W` : 기본 라틴 알파벳에 해당하지 않는 word character에 매치 == `[^A-Za-z0-9_]`
- `\s` : 공백 문자 escape == `[\f\n\r\t\v\u0020\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`

---

## RegExp() 생성자

[mdn docs](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp)
RegExp 생성자는 패턴을 사용해 텍스트를 판별할 때 사용하는 정규 표현식 객체를 생성합니다.

### 구문

- 표기

  - 리터럴 : `/pattenrs/flgs`
  - 생성자 : `new RegExp(pattern[, flags])`
  - 팩토리 표기법 가능 `RegExp(pattern[, flags])`

- 매개 변수
  - 패턴 : 정규 표현식을 나타내는 텍스트, 패턴은 특수 문자가 포함 가능해 더 넓은 범위의 값을 판별할 수 있음
  - 플래그 : 정규 표현식에 추가할 플래그.
    - `g` : 문자열 전체 판별
    - `i` : 대소문자 무시 (정규식은 기본적으로 대소문자 구분)
    - `m` : 여러 줄 확인
    - `s` : "dotAll" `.` 이 줄바꿈에도 일치?
    - `u` : 유니코드
    - `y` : stikcy?

### 참고

[JavaScript 정규 표현식 문법 총정리 + 응용 예제](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EC%A0%95%EA%B7%9C%EC%8B%9D-RegExp-%EB%88%84%EA%B5%AC%EB%82%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EC%89%BD%EA%B2%8C-%EC%A0%95%EB%A6%AC)
