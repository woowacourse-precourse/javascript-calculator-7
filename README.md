# javascript-calculator-precourse


## 기능 요구 사항
**입력한 문자열에서 숫자를 추출하여 더하는 계산기를 구현한다.**
쉼표(,) 또는 콜론(:)을 구분자로 가지는 문자열을 전달하는 경우 구분자를 기준으로 분리한 각 숫자의 합을 반환한다.

1. 기본 구분자(쉼표, 콜론)로 문자열에서 숫자를 추출해 합을 반환한다.
2. 커스텀 구분자가 있는 문자열의 경우, 커스텀 구분자로도 숫자를 추출한다.
3. 사용자의 잘못된 입력을 에러 처리한 후, 애플리케이션을 종료한다.
  a. [ERROR] 구분자와 양수로 이뤄진 문자열을 작성해주세요.
  b. [ERROR] 기본 구분자와 커스텀 구분자만 사용해주세요.
  c. [ERROR] 커스텀 구분자는 기본 구분자를 제외하여 정의해주세요.


## 구현할 것
- [x] 기본 입출력 받기
  - 기본 입출력
  - 구분자를 배열에 정의
- [x] 커스텀 구분자 추출
  - '//' 시작 여부 확인
  - '\n' 기준으로 나누기
  - 구분자 배열에 커스텀 구분자 삽입
- [x] 숫자 추출
  - 구분자 기준으로 나누어 저장
  - 두자리 이상의 정수가 입력된 경우 처리
  - 배열 순회하며 합
- [x] 예외 처리
  - 음수를 입력한 경우
  - 잘못된 구분자를 사용한 경우
  - 커스텀 구분자의 잘못된 정의


## 트러블 슈팅

1️⃣ **``'\n'`` 이스케이프 문자 포함 이슈**
커스텀 구분자를 추출할 때, 이스케이프 문자가 추가되는 이슈가 있었습니다.

``\n`` 문자를 기준으로 입력을 split할 때, ``input.split('\\n')``를 사용하여 customDelimiter, inputString으로 분리했고,
이 과정에서 customDelimiter에서 ``'//'``을 제거하여 추출한 구분자를 delimiters 배열에 추가했습니다.

그러나 delimiters 배열에 자꾸 ``[',', ':', ';\']`` 와 같이 이스케이프 문자가 딸려 나오는 문제가 발생하였고,
그래서 ``slice(2)``에서 ``split('')[2]``로 수정해 ``'//'`` 다음에 오는 하나의 문자만 커스텀 구분자로 지정하였습니다. 

황당하게도, 문제의 원인은 테스트코드 인풋인 ``//;\\n1``를 그대로 인풋에 넣어버린 것이었습니다. 
자바스크립트 코드 내에서는 백슬래시를 표기할 때 이스케이프 처리를 해야 하므로 실제 인풋으로 들어가는 스트링은 ``//;\n1``이었다는 사실!

2️⃣ **``parseInt(0) === false`` 이슈**
숫자와 구분자를 검사할 때, inputString 에서 숫자를 추출하는 과정에서 문제가 발생했습니다.

inputString을 하나씩 떼어 검사하고, 두 자릿수 이상 숫자를 처리하기 위해 숫자 문자열을 누적하다가 구분자가 나타나면 누적된 숫자를 추출하는 로직을 사용했습니다.
그러나 0을 마주하면 "구분자가 아닌 스트링"으로 처리가 되므로 에러로 던져지는 이슈가 존재했습니다.

문자일 경우, ``parseInt(str) === NaN`` 이므로 falsy 값을 반환한다는 점을 이용하여 구분했는데,
0이 들어오는 경우, 0 또한 falsy값 이므로 문자열로 처리되고, 구분자도 아니므로 에러로 던져졌던 것입니다.
구현을 끝내고 생각해보니, 정규식으로 숫자를 필터링했다면 이런 이슈가 안 발생했을 것 같습니다.